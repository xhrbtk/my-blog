- 超文本传输协议（HTTP）是用于传输诸如HTML的超媒体文档的应用层协议。它被设计用于Web浏览器和Web服务器之间的通信，但它也可以用于其他目的。http协议是无状态协议
- 请求报文：请求方法（get、post），请求路径，协议版号，为服务端表达其他信息的可选头部headers
- 响应报文：http协议版本号，状态码，状态信息：这个信息是非权威的状态码描述信息，可以由服务端自行设定，http headers与请求头类似，可选项：比起请求报文，响应报文中更常见的包含获取的body信息
- http消息投允许客户端和服务器通过request和response传递附加消息。
### 根据不同上下文，可将消息头分为：
-  一般头：同时适用于请求和响应消息，但与最终消息主题中传输的数据无关的消息头
- 请求头：包含有关要获取的资源或客户端本身更多信息的消息头
- 响应头：包含有关服务器相应的补充信息，如其位置或服务器本身的消息头
- 实体头：包含有关实体主体的更多信息，比如主体长度或其mimi类型
### 缓存：
重用获取的资源能够有效的提升网站与应用的性能。web缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间。借助http缓存，web沾点变更具有响应性‘。’
- 缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。好处：缓解服务器端压力，提升性能（获取资源的耗时更短了）。对于网站来说，缓存是达到高性能的组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的。重要的是对一个资源的缓存应截止到其下一次发生改变。
- 缓存的种类有很多，其大致可归为两类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。
- 浏览器与代理缓存，网关缓存，cdn，反向代理缓存和负载均衡器等部署在服务器上
- 私有缓存只能用于单用户，这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看代码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览
- 共有缓存可以被多个用户使用。你所在的公司可能会架设一个web代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复施使用，减少网络拥堵与延迟。
### 缓存操作的目标：
- 虽然http缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的http缓存只能存储get响应，对于其他类型的响应则无能为力。缓存的关键主要包括request method和目标uri
```
一个检索请求的成功响应：对于get请求，响应状态码为：200，则表示为成功。一个包含例如html文档，图片或者文件的响应
不变的重定向：响应状态码：301
错误响应：响应状态码：404的一个页面
不完全的响应：响应状态码206，只返回局部的信息
除了get请求外，如果匹配到作为一个已被定义的cache键名的响应
```
### 缓存控制：Cache-Control头用来区分对缓存机制的支持情况，请求头和响应头都支持这个属性。通过它提供的不同的值来定义缓存策略
### 缓存过期机制：过期机制中，最重要的是“max-age=<seconds>”，表示自愿能够被缓存的最大时间。相对Expires而言，max-age是距离请求发起的时间的秒数。
### 缓存验证确认：当使用了“must-revalidate”指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。Cache-Control:must-revalidate
### 新鲜度：理论上来讲，当一个资源被缓存存储后，该资源应该可以被永久存储在缓存中。该资源应该可以被永久存储在缓存中。由于缓存只有有限的空间用于存储资源副本，所以会定期的将一些副本删除，这个过程叫做缓存驱逐。另一方面，当服务器上面的资源进行了更新，那么缓存中的对应资源也应该被更新，由http是c/s模式的协议，服务器更新一个资源时，不可能直接通知客户端及其缓存，所以双方必须为该资源约定一个过期时间，在该过期时间之前，该资源（缓存副本）就是新鲜的，当过了过期时间后，该资源（缓存副本）是不会直接被清除或忽略的，当客户端发起一个请求时，缓存检索到已有一个对应的陈旧资源，则缓存会将此请求附加一个 if-none-match头，然后发给目标服务器，以此来检查该资源副本是否是依然还是算新鲜的，若服务器返回了304（该响应不会带有实体信息），则表示此资源副本是新鲜的，这样一来，可以节省一些贷款。若服务器通过if-none-match或if-modified-since判断后发现已过期，那么会带有该资源的实体内容返回。
- 对于含有特定头信息的请求，会去计算缓存寿命。比如Cache-control：max-age=n的请求头，相应的缓存的寿命就是n，通常情况下，对于不含这个属性的请求则会去查看是否包含Expires属性，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。如果max-age和expires属性都没有，找找头里的last-Modified信息。如果有，缓存的寿命就等于头里面Date的值减去Last-Modfied的值除以10
### 缓存验证
- 用户点击刷新按钮时会开始缓存验证。如果缓存的响应头信息里含有“Cache-control：must-revalidate”的定义，在浏览的过程中也会触发缓存验证。另外，在浏览器偏好设置里设置Advanced>Cache为强制验证缓存也能达到相同效果。
- 当缓存的文档过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回强校验器或者弱校验器时才会进行验证。
### 缓存失效时间：responseTime表示浏览器接收到此响应的那个时间点
- expirationTime = responseTime + freshnessLifetime - currentAge
### 作为缓存的一种强校验器，ETag响应头是一个对用户代理不透明的值。对于像浏览器这样的http，不知道ETag
代表什么，不能预测它的值是多少。如果资源请求的响应头里含有ETag，客户端可以在后续的请求的头中带上if-None-Match来验证缓存。
- Last-Modified响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上If-Modified-Since来验证缓存。
- 当服务器端发起缓存校验的请求时，服务端会返回200 ok表示返回正常的结果或者304 （不返回body）表示浏览器可以使用本地缓存文件。304的响应头也可以同时更新缓存文档过期时间。

###HTTP Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务器端两个请求是否来自同一浏览器，如果保持用户的登陆状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。
```
Cookie主要用于以下三个方面：
1.会话状态管理（如用户登陆状态，购物车，游戏分数或其他需要记录的信息）
2.个性化设置（如用户自定义设置，主题等）
3.浏览器行为跟踪（如跟踪分析用户行为等）
```
Cookie曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着浏览器开始支持各种各样的存储方式，Cookie渐渐被淘汰。由于服务器指定Cookie后，浏览器的每次请求都会携带Cookie数据，会带俩额外的性能开销。新的浏览器API已经允许开发者直接将数据存储到本地，如使用web storage
```
web storage包含如下两种机制：
- sessionStorage为每一个给定的源维持一个独立的存储区域，该存储区域在页面会话期间可用（只要浏览器出于打开状态，包括页面重新加载和恢复）
- localStorage同样的功能，当时在浏览器关闭，然后重新打开后数据仍然存在

```
### 创建Cookie
- 当服务器收到HTTP请求时，服务器可以在响应头里面添加一个Set-Cookie选项。浏览器收到响应后通常会保存下Cookie，之后对该服务器每一次请求中都通过Cookie请求头部将Cookie信息发送给服务器。另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。
### Set-Cookie响应头部和Cookie请求头部：
- 服务器使用Set-Cookie响应头部向用户代理（一般是浏览器）发送Cookie信息。服务器通过该头部告知客户端保存Cookie信息。
- 现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过Cookie请求头部再发送会给服务器。
### 会话期Cookie
- 会话期Cookie是最简单的Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。会话期Cookie不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie也会被保留下来，就好像浏览器从来没有关闭一样。
- 持久性Cookie：和关闭浏览器便师兄啊的会话器Cookie不同，持久性Cookie可以指定一个特定的过期时间（Expires）或者有效期（Max-Age）
